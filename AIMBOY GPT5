-- Roblox — ChatGPT-style Integration (Client UI + Server Proxy)
-- FILE: Roblox_ChatGPT5_Integration.lua
-- This single file bundles multiple scripts (ModuleScript, Server Script, LocalScript) you should split
-- into appropriate places in your Roblox project as described below.
--
-- IMPORTANT SAFETY & SETUP NOTES
-- 1) Never put your OpenAI API key inside a LocalScript or anywhere accessible to clients.
--    Store it in a Server Script Module (Server-only) or a secure server environment.
-- 2) Enable HttpService in Studio: Home > Game Settings > Security > Enable Http Requests
-- 3) This example calls an OpenAI-like HTTP endpoint. Replace MODEL_NAME and ENDPOINT with the
--    correct values from OpenAI docs. The code below uses a generic Chat Completions POST.
-- 4) Watch out for costs and rate limits. Implement throttling/quotas for players.
-- 5) This integration is intended for developer-owned worlds where you control both client and server.
--
-- HOW TO SPLIT INTO ROBLOX ASSETS
-- 1) Create a ModuleScript in ServerScriptService named `OpenAI_Module` and paste the OpenAI module code.
-- 2) Create a Script in ServerScriptService named `ChatServer` and paste the server handler code.
-- 3) Create a RemoteFunction in ReplicatedStorage named `ChatRequestFunction`.
-- 4) Create a ScreenGui + LocalScript in StarterPlayerScripts named `ChatClient` and paste the client UI code.
--
-- -----------------------------------------------------------------------------
-- [A] ModuleScript (ServerScriptService/OpenAI_Module)
-- Put only on the server. Add your API key inside the module (or require from a secure source).
-- -----------------------------------------------------------------------------
local OpenAIModule = {}

local HttpService = game:GetService("HttpService")

-- CONFIG: change these to match your OpenAI / provider settings
OpenAIModule.API_ENDPOINT = "https://api.openai.com/v1/chat/completions" -- example
OpenAIModule.MODEL = "YOUR_MODEL_NAME" -- e.g. "gpt-5-thinking-mini" or whichever model you have access to
OpenAIModule.API_KEY = "REPLACE_WITH_YOUR_API_KEY" -- **DO NOT** put this in a LocalScript!

-- Simple helper for POSTing a chat request
function OpenAIModule:RequestChat(systemPrompt, userMessage)
    assert(type(systemPrompt) == "string")
    assert(type(userMessage) == "string")

    -- Build the payload following chat-completions style
    local body = {
        model = self.MODEL,
        messages = {
            { role = "system", content = systemPrompt },
            { role = "user", content = userMessage },
        },
        max_tokens = 600,
        temperature = 0.7,
    }

    local jsonBody = HttpService:JSONEncode(body)

    local headers = {
        ["Content-Type"] = "application/json",
        ["Authorization"] = "Bearer " .. self.API_KEY,
    }

    -- RequestAsync gives more control; using pcall to catch issues
    local ok, res = pcall(function()
        return HttpService:RequestAsync({
            Url = self.API_ENDPOINT,
            Method = "POST",
            Headers = headers,
            Body = jsonBody,
            Timeout = 20,
        })
    end)

    if not ok then
        return false, "HTTP request failed: " .. tostring(res)
    end

    if res.Success then
        -- parse response body
        local decoded = HttpService:JSONDecode(res.Body)
        -- navigate typical response structure -- adapt if provider differs
        local content = nil
        if decoded and decoded.choices and #decoded.choices > 0 and decoded.choices[1].message then
            content = decoded.choices[1].message.content
        elseif decoded and decoded.choices and #decoded.choices > 0 and decoded.choices[1].text then
            content = decoded.choices[1].text
        end
        return true, content or "(no content)"
    else
        return false, "API error: " .. tostring(res.StatusCode) .. " - " .. tostring(res.Body)
    end
end

return OpenAIModule

-- -----------------------------------------------------------------------------
-- [B] Server Script (ServerScriptService/ChatServer)
-- Handles requests from clients via RemoteFunction and proxies them to OpenAI_Module
-- -----------------------------------------------------------------------------
--[[
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local ChatRequestFunction = ReplicatedStorage:WaitForChild("ChatRequestFunction") -- RemoteFunction
local OpenAIModule = require(game:GetService("ServerScriptService"):WaitForChild("OpenAI_Module"))

-- Simple rate-limiter table (per-player)
local lastRequestAt = {}
local MIN_INTERVAL = 1.2 -- seconds between requests per player (adjust as needed)

ChatRequestFunction.OnServerInvoke = function(player, userMessage)
    if type(userMessage) ~= "string" then
        return { ok = false, error = "Invalid message" }
    end

    local now = tick()
    local last = lastRequestAt[player.UserId]
    if last and now - last < MIN_INTERVAL then
        return { ok = false, error = "Too many requests. Slow down." }
    end
    lastRequestAt[player.UserId] = now

    -- Basic sanitization: length limits
    if #userMessage > 2000 then
        return { ok = false, error = "Message too long" }
    end

    -- Build a system prompt describing the assistant persona and constraints
    local systemPrompt = "You are an in-game assistant for a Roblox world. Keep answers concise and safe for general audiences. Avoid giving cheats or exploit instructions."

    local ok, result = OpenAIModule:RequestChat(systemPrompt, userMessage)
    if not ok then
        return { ok = false, error = result }
    end

    return { ok = true, text = result }
end
]]-- end server script

-- -----------------------------------------------------------------------------
-- [C] Client UI (StarterPlayerScripts: LocalScript + ScreenGui creation)
-- A stylish floating chat block that calls the RemoteFunction to get replies.
-- -----------------------------------------------------------------------------
--[[
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Ensure RemoteFunction exists
local ChatRequestFunction = ReplicatedStorage:WaitForChild("ChatRequestFunction")

-- Build GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ChatGPT_UI"
screenGui.ResetOnSpawn = false

local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 420, 0, 140)
main.Position = UDim2.new(0.5, -210, 0.25, -70)
main.AnchorPoint = Vector2.new(0.5, 0.5)
main.BackgroundColor3 = Color3.fromRGB(12,12,16)
main.BackgroundTransparency = 0
main.BorderSizePixel = 0
main.Parent = screenGui
local mainCorner = Instance.new("UICorner", main)
mainCorner.CornerRadius = UDim.new(0, 12)

-- Header (for dragging) and title
local header = Instance.new("Frame", main)
header.Size = UDim2.new(1, 0, 0, 34)
header.Position = UDim2.new(0,0,0,0)
header.BackgroundTransparency = 1

local title = Instance.new("TextLabel", header)
title.Size = UDim2.new(0.6, -12, 1, 0)
title.Position = UDim2.new(0, 12, 0, 0)
title.BackgroundTransparency = 1
title.Text = "GPT-5 Assistant"
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextColor3 = Color3.fromRGB(235,235,235)

-- small status icon
local status = Instance.new("Frame", header)
status.Size = UDim2.new(0, 10, 0, 10)
status.Position = UDim2.new(0.6, 0, 0.5, -5)
status.BackgroundColor3 = Color3.fromRGB(80,200,120)
local statusCorner = Instance.new("UICorner", status)
statusCorner.CornerRadius = UDim.new(0, 6)

-- close/minimize buttons
local closeBtn = Instance.new("TextButton", header)
closeBtn.Size = UDim2.new(0, 30, 0, 24)
closeBtn.Position = UDim2.new(1, -38, 0.5, -12)
closeBtn.Text = "—"
closeBtn.Font = Enum.Font.Gotham
closeBtn.TextSize = 18
closeBtn.BackgroundColor3 = Color3.fromRGB(30,30,34)
closeBtn.BorderSizePixel = 0
local closeCorner = Instance.new("UICorner", closeBtn)
closeCorner.CornerRadius = UDim.new(0,6)

-- Body: scrollable chat area
local chatArea = Instance.new("ScrollingFrame", main)
chatArea.Size = UDim2.new(1, -24, 1, -76)
chatArea.Position = UDim2.new(0, 12, 0, 44)
chatArea.BackgroundTransparency = 1
chatArea.ScrollBarThickness = 6
chatArea.CanvasSize = UDim2.new(0,0,0,0)
chatArea.AutomaticCanvasSize = Enum.AutomaticSize.Y

local uiList = Instance.new("UIListLayout", chatArea)
uiList.SortOrder = Enum.SortOrder.LayoutOrder
uiList.Padding = UDim.new(0,6)

-- Input Box
local inputBox = Instance.new("TextBox", main)
inputBox.Size = UDim2.new(1, -24, 0, 28)
inputBox.Position = UDim2.new(0, 12, 1, -34)
inputBox.ClearTextOnFocus = false
inputBox.Text = "พิมพ์คำถามของคุณ..."
inputBox.Font = Enum.Font.Gotham
inputBox.TextSize = 16
inputBox.TextColor3 = Color3.fromRGB(230,230,230)
inputBox.BackgroundColor3 = Color3.fromRGB(24,24,28)
inputBox.BorderSizePixel = 0
local inputCorner = Instance.new("UICorner", inputBox)
inputCorner.CornerRadius = UDim.new(0,8)

-- Helper: add chat bubble
local function addBubble(text, fromPlayer)
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 0, 0)
    frame.BackgroundTransparency = 1
    frame.LayoutOrder = #chatArea:GetChildren() + 1

    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(1, -12, 0, 0)
    label.Position = UDim2.new(0,6,0,0)
    label.BackgroundTransparency = 1
    label.TextWrapped = true
    label.Text = text
    label.Font = Enum.Font.Gotham
    label.TextSize = 16
    label.TextColor3 = fromPlayer and Color3.fromRGB(200,200,255) or Color3.fromRGB(240,240,240)

    -- dynamic sizing
    local textBounds = game:GetService("TextService"):GetTextSize(text, 16, label.Font, Vector2.new(360, 6000))
    label.Size = UDim2.new(1, -12, 0, math.clamp(textBounds.Y + 8, 20, 400))
    frame.Size = UDim2.new(1, 0, 0, label.Size.Y.Offset)

    frame.Parent = chatArea
    chatArea.CanvasPosition = Vector2.new(0, 999999)
end

-- Draggable by header: corner-drag behavior (hold to drag top-left 28x28 px)
local dragging = false
local dragOffset = Vector2.new()
local cornerSize = Vector2.new(28,28)

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local mouse = Players.LocalPlayer:GetMouse()
        local relX = mouse.X - main.AbsolutePosition.X
        local relY = mouse.Y - main.AbsolutePosition.Y
        if relX >= 0 and relY >= 0 and relX <= cornerSize.X and relY <= cornerSize.Y then
            dragging = true
            dragOffset = Vector2.new(relX, relY)
        end
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = false
    end
end)
RunService.RenderStepped:Connect(function()
    if dragging then
        local mouse = Players.LocalPlayer:GetMouse()
        local newX = mouse.X - dragOffset.X
        local newY = mouse.Y - dragOffset.Y
        -- keep on screen
        local maxX = Camera.ViewportSize.X - main.AbsoluteSize.X
        local maxY = Camera.ViewportSize.Y - main.AbsoluteSize.Y
        newX = math.clamp(newX, 0, math.max(0, maxX))
        newY = math.clamp(newY, 0, math.max(0, maxY))
        main.Position = UDim2.new(0, newX, 0, newY)
    end
end)

-- Send request to server and await response
local function sendQuery(text)
    if type(text) ~= "string" or text:match("^%s*$") then return end
    addBubble(text, true)
    inputBox.Text = ""

    -- invoke server
    local ok, res = pcall(function()
        return ChatRequestFunction:InvokeServer(text)
    end)

    if not ok then
        addBubble("ข้อผิดพลาดเชื่อมต่อ: " .. tostring(res), false)
        return
    end

    if not res.ok then
        addBubble("Error: " .. tostring(res.error), false)
        return
    end

    addBubble(tostring(res.text), false)
end

-- Input events
inputBox.FocusLost:Connect(function(enter)
    if enter then
        local txt = inputBox.Text
        sendQuery(txt)
    end
end)

closeBtn.MouseButton1Click:Connect(function()
    local visible = screenGui.Enabled
    screenGui.Enabled = not visible
end)

-- Parent the GUI
screenGui.Parent = PlayerGui
]]-- end client UI

-- -----------------------------------------------------------------------------
-- END OF FILE
-- -----------------------------------------------------------------------------
-- Reminder: Paste each marked section into the correct Roblox asset and configure
-- OpenAIModule.API_KEY and OpenAIModule.MODEL on the server module. Test in Studio
-- with HttpService enabled. Implement additional security, caching, and rate-limits
-- for production.
-- -----------------------------------------------------------------------------
